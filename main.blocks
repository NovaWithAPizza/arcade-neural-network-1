<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="Bo5$kTfj8OS3xc9r]^yI" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="Q#?9e@{z[jjb[Ie8y$z{" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace AI {" line1="    //% block" line2="export function MakeNet(Inputs: number, Layers: number, Neurons: number, Outputs: number) {" line3="    let OutputArray: number[][][] = []" line4="    let TempArray: number[] = []" line5="    let _var = 0" line6="    let xednI = 0" line7="    let value = 0" line8="    let ArrayTemp: number[] = []" line9="    OutputArray = []" line10="    TempArray = []" line11="    for (let index = 0; index &lt; Inputs + 1; index++) {" line12="        TempArray.push(0)" line13="    }" line14="    OutputArray.push([TempArray])" line15="    for (let index2 = 0; index2 &lt; Neurons - 1; index2++) {" line16="        OutputArray[0].push(TempArray)" line17="    }" line18="    TempArray = []" line19="    for (let index3 = 0; index3 &lt; Neurons + 1; index3++) {" line20="        TempArray.push(0)" line21="    }" line22="    OutputArray.push([TempArray])" line23="    for (let index4 = 0; index4 &lt; Layers - 1; index4++) {" line24="        for (let index5 = 0; index5 &lt; Neurons - 1; index5++) {" line25="            OutputArray[OutputArray.length - 1].push(TempArray)" line26="        }" line27="    }" line28="    OutputArray.push([TempArray])" line29="    return OutputArray" line30="}" line31="export function Accuracy(Net: any[], Inputs: number, Neurons: number, Layers: number, Outputs: number, InputOutput: number[][][]) {" line32="    let OutputArray2: number[][][] = []" line33="    let TempArray2: number[] = []" line34="    let _var2 = 0" line35="    let xednI2 = 0" line36="    let value2 = 0" line37="    let ArrayTemp2: number[] = []" line38="    _var2 = 0" line39="    for (let value22 of InputOutput) {" line40="        for (let index6 = 0; index6 &lt;= Outputs - 1; index6++) {" line41="            _var2 += value22[1][index6] - Think(Net, value22[0], Neurons, Layers, Outputs)[index6]" line42="        }" line43="    }" line44="    return _var2 / InputOutput.length" line45="}" line46="export function Mutate(Net: number[][][], Inputs: number, Neurons: number, Layers: number, Outputs: number) {" line47="    let OutputArray3: number[][][] = []" line48="    let TempArray3: number[] = []" line49="    let _var3 = 0" line50="    let xednI3 = 0" line51="    let value3 = 0" line52="    let ArrayTemp3: number[] = []" line53="    OutputArray3 = MakeNet(Inputs, Neurons, Layers, Outputs)" line54="    for (let index7 = 0; index7 &lt;= Neurons - 1; index7++) {" line55="        xednI3 = 0" line56="        for (let index8 = 0; index8 &lt; Inputs + 1; index8++) {" line57="            OutputArray3[0][index7][xednI3] = Math.constrain((Net[0][index7][xednI3] * 100 + randint(-10, 10)) / 100, 0, 1)" line58="            xednI3 += 1" line59="        }" line60="    }" line61="    value3 = 1" line62="    for (let index9 = 0; index9 &lt; Layers - 1; index9++) {" line63="        for (let index92 = 0; index92 &lt;= Neurons - 1; index92++) {" line64="            xednI3 = 0" line65="            for (let index10 = 0; index10 &lt; Neurons + 1; index10++) {" line66="                OutputArray3[value3][index92][xednI3] = Math.constrain((Net[value3][index92][xednI3] * 100 + randint(-10, 10)) / 100, 0, 1)" line67="                xednI3 += 1" line68="            }" line69="        }" line70="        value3 += 1" line71="    }" line72="    for (let index102 = 0; index102 &lt;= Outputs - 1; index102++) {" line73="        xednI3 = 0" line74="        for (let index11 = 0; index11 &lt; Neurons + 1; index11++) {" line75="            OutputArray3[value3][index102][xednI3] = Math.constrain((Net[value3][index102][xednI3] * 100 + randint(-10, 10)) / 100, 0, 1)" line76="            xednI3 += 1" line77="        }" line78="    }" line79="    return OutputArray3" line80="}" line81="export function Think(Net: number[][][], Inputs: number[], Neurons: number, Layers: number, Outputs: number) {" line82="    let OutputArray4: number[][][] = []" line83="    let TempArray4: number[] = []" line84="    let _var4 = 0" line85="    let xednI4 = 0" line86="    let value4 = 0" line87="    let ArrayTemp4: number[] = []" line88="    TempArray4 = [0]" line89="    for (let index12 = 0; index12 &lt; Inputs.length; index12++) {" line90="        TempArray4.push(0)" line91="    }" line92="    for (let index122 = 0; index122 &lt;= Neurons - 1; index122++) {" line93="        for (let value32 of Inputs) {" line94="            TempArray4[index122] = TempArray4[index122] + Net[0][index122][Inputs.indexOf(value32) + 1] * value32" line95="        }" line96="        TempArray4[index122] = Math.constrain(TempArray4[index122] + Net[0][index122][0], 0, 1)" line97="    }" line98="    ArrayTemp4 = []" line99="    for (let index13 = 0; index13 &lt; Neurons; index13++) {" line100="        ArrayTemp4.push(0)" line101="    }" line102="    xednI4 = 1" line103="    for (let index14 = 0; index14 &lt; Layers - 1; index14++) {" line104="        for (let index15 = 0; index15 &lt;= Neurons - 1; index15++) {" line105="            for (let value42 of TempArray4) {" line106="                ArrayTemp4[index15] = ArrayTemp4[index15] + Net[xednI4][index15][TempArray4.indexOf(value42) + 1] * value42" line107="            }" line108="            ArrayTemp4[index15] = Math.constrain(ArrayTemp4[index15] + Net[xednI4][index15][0], 0, 1)" line109="        }" line110="        TempArray4 = ArrayTemp4" line111="        ArrayTemp4 = [0]" line112="        for (let index16 = 0; index16 &lt; Neurons; index16++) {" line113="            ArrayTemp4.push(0)" line114="        }" line115="        xednI4 += 1" line116="    }" line117="    ArrayTemp4 = [0]" line118="    for (let index17 = 0; index17 &lt; Outputs - 1; index17++) {" line119="        ArrayTemp4.push(0)" line120="    }" line121="    for (let index18 = 0; index18 &lt;= Outputs - 1; index18++) {" line122="        for (let value5 of TempArray4) {" line123="            ArrayTemp4[index18] = ArrayTemp4[index18] + Net[xednI4][index18][TempArray4.indexOf(value5) + 1] * value5" line124="        }" line125="        ArrayTemp4[index18] = Math.constrain(ArrayTemp4[index18] + Net[xednI4][index18][0], 0, 1)" line126="    }" line127="    return ArrayTemp4" line128="}" line129="}" numlines="130"></mutation></block></statement></block></xml>